/* -LICENSE-START-
** Copyright (c) 2011 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#import "SwitcherPanelAppDelegate.h"
#import "CallbackMonitors.h"
#include <libkern/OSAtomic.h>
#include <os/atomic.h>
#include <string>

static inline bool	operator== (const REFIID& iid1, const REFIID& iid2)
{ 
	return CFEqual(&iid1, &iid2);
}

// Callback class for monitoring property changes on a mix effect block.
class MixEffectBlockMonitor : public IBMDSwitcherMixEffectBlockCallback
{
public:
	MixEffectBlockMonitor(SwitcherPanelAppDelegate* uiDelegate) : mUiDelegate(uiDelegate), mRefCount(1) { }

protected:
	virtual ~MixEffectBlockMonitor() { }

public:
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		if (!ppv)
			return E_POINTER;
		
		if (iid == IID_IBMDSwitcherMixEffectBlockCallback)
		{
			*ppv = static_cast<IBMDSwitcherMixEffectBlockCallback*>(this);
			AddRef();
			return S_OK;
		}
		
		if (CFEqual(&iid, IUnknownUUID))
		{
			*ppv = static_cast<IUnknown*>(this);
			AddRef();
			return S_OK;
		}
		
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef(void)
	{
        return  os_atomic_std(atomic_fetch_add_explicit)(
                                                         os_cast_to_atomic_pointer(&mRefCount), 1,
                                                         os_atomic_std(memory_order_relaxed));
		//return ::OSAtomicIncrement32(&mRefCount);
	}

	ULONG STDMETHODCALLTYPE Release(void)
	{
        int newCount = os_atomic_std(atomic_fetch_sub_explicit)(
                                                                os_cast_to_atomic_pointer(&mRefCount), 1,
                                                                os_atomic_std(memory_order_relaxed));
		//int newCount = ::OSAtomicDecrement32(&mRefCount);
		if (newCount == 0)
			delete this;
		return newCount;
	}
	
	HRESULT Notify(BMDSwitcherMixEffectBlockEventType eventType)
	{
		switch (eventType)
		{
			case bmdSwitcherMixEffectBlockEventTypeProgramInputChanged:
				[mUiDelegate performSelectorOnMainThread:@selector(updateProgramButtonSelection) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockEventTypePreviewInputChanged:
				[mUiDelegate performSelectorOnMainThread:@selector(updatePreviewButtonSelection) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockEventTypeInTransitionChanged:
				[mUiDelegate performSelectorOnMainThread:@selector(updateInTransitionState) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockEventTypeTransitionPositionChanged:
				[mUiDelegate performSelectorOnMainThread:@selector(updateSliderPosition) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockEventTypeTransitionFramesRemainingChanged:
				[mUiDelegate performSelectorOnMainThread:@selector(updateTransitionFramesTextField) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockEventTypeFadeToBlackFramesRemainingChanged:
				[mUiDelegate performSelectorOnMainThread:@selector(updateFTBFramesTextField) withObject:nil waitUntilDone:YES];
				break;
			default:	// ignore other property changes not used for this sample app
				break;
		}
		return S_OK;
	}

private:
	SwitcherPanelAppDelegate*		mUiDelegate;
	int								mRefCount;
};

// Monitor the properties on Switcher Inputs.
// In this sample app we're only interested in changes to the Long Name property to update the PopupButton list
class InputMonitor : public IBMDSwitcherInputCallback
{
public:
	InputMonitor(IBMDSwitcherInput* input, SwitcherPanelAppDelegate* uiDelegate) : mInput(input), mUiDelegate(uiDelegate), mRefCount(1)
	{
		mInput->AddRef();
		mInput->AddCallback(this);
	}

protected:
	~InputMonitor()
	{
		mInput->RemoveCallback(this);
		mInput->Release();
	}
	
public:
	// IBMDSwitcherInputCallback interface
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		if (!ppv)
			return E_POINTER;
		
		if (iid == IID_IBMDSwitcherInputCallback)
		{
			*ppv = static_cast<IBMDSwitcherInputCallback*>(this);
			AddRef();
			return S_OK;
		}
		
		if (CFEqual(&iid, IUnknownUUID))
		{
			*ppv = static_cast<IUnknown*>(this);
			AddRef();
			return S_OK;
		}
		
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef(void)
	{
        return  os_atomic_std(atomic_fetch_add_explicit)(
                                                         os_cast_to_atomic_pointer(&mRefCount), 1,
                                                         os_atomic_std(memory_order_relaxed));
		//return ::OSAtomicIncrement32(&mRefCount);
	}

	ULONG STDMETHODCALLTYPE Release(void)
	{
        int newCount = os_atomic_std(atomic_fetch_sub_explicit)(
                                                                os_cast_to_atomic_pointer(&mRefCount), 1,
                                                                os_atomic_std(memory_order_relaxed));
        //int newCount = ::OSAtomicDecrement32(&mRefCount);
		if (newCount == 0)
			delete this;
		return newCount;
	}

	HRESULT Notify(BMDSwitcherInputEventType eventType)
	{
		switch (eventType)
		{
			case bmdSwitcherInputEventTypeLongNameChanged:
				[mUiDelegate performSelectorOnMainThread:@selector(updatePopupButtonItems) withObject:nil waitUntilDone:YES];
			default:	// ignore other property changes not used for this sample app
				break;
		}
		
		return S_OK;
	}
	IBMDSwitcherInput* input() { return mInput; }
	
private:
	IBMDSwitcherInput*			mInput;
	SwitcherPanelAppDelegate*	mUiDelegate;
	int							mRefCount;
};

// Callback class to monitor switcher disconnection
class SwitcherMonitor : public IBMDSwitcherCallback
{
public:
	SwitcherMonitor(SwitcherPanelAppDelegate* uiDelegate) :	mUiDelegate(uiDelegate), mRefCount(1) { }

protected:
	virtual ~SwitcherMonitor() { }
	
public:
	// IBMDSwitcherCallback interface
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		if (!ppv)
			return E_POINTER;
		
		if (iid == IID_IBMDSwitcherCallback)
		{
			*ppv = static_cast<IBMDSwitcherCallback*>(this);
			AddRef();
			return S_OK;
		}
		
		if (CFEqual(&iid, IUnknownUUID))
		{
			*ppv = static_cast<IUnknown*>(this);
			AddRef();
			return S_OK;
		}
		
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef(void)
	{
        return  os_atomic_std(atomic_fetch_add_explicit)(
                                                         os_cast_to_atomic_pointer(&mRefCount), 1,
                                                         os_atomic_std(memory_order_relaxed));
		//return ::OSAtomicIncrement32(&mRefCount);
	}

	ULONG STDMETHODCALLTYPE Release(void)
	{
        int newCount = os_atomic_std(atomic_fetch_sub_explicit)(
                                                                os_cast_to_atomic_pointer(&mRefCount), 1,
                                                                os_atomic_std(memory_order_relaxed));
        //int newCount = ::OSAtomicDecrement32(&mRefCount);
		if (newCount == 0)
			delete this;
		return newCount;
	}
	
	// Switcher events ignored by this sample app
	HRESULT STDMETHODCALLTYPE	Notify(BMDSwitcherEventType eventType, BMDSwitcherVideoMode coreVideoMode)
	{
		if (eventType == bmdSwitcherEventTypeDisconnected)
		{
			[mUiDelegate performSelectorOnMainThread:@selector(switcherDisconnected) withObject:nil waitUntilDone:YES];
		}
		return S_OK;
	}
	
private:
	SwitcherPanelAppDelegate*	mUiDelegate;
	int							mRefCount;
};


@implementation SwitcherPanelAppDelegate

@synthesize window;

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
	mSwitcherDiscovery = NULL;
	mSwitcher = NULL;
	mMixEffectBlock = NULL;
	
	mSwitcherMonitor = new SwitcherMonitor(self);
	mMixEffectBlockMonitor = new MixEffectBlockMonitor(self);
	
	mMoveSliderDownwards = false;
	mCurrentTransitionReachedHalfway = false;
	
	mSwitcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (! mSwitcherDiscovery)
	{
		NSAlert* alert = [[NSAlert alloc] init];
		[alert setMessageText:@"Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.\n"];
		[alert addButtonWithTitle:NSLocalizedString(@"OK", nil)];
		[alert beginSheetModalForWindow:window completionHandler:^(NSModalResponse returnCode) {
			[NSApp terminate:self];
		}];
	}
    
    mStills = NULL;
    mSwitcherMonitor = new SwitcherMonitor(self);
    mMediaPlayer1Monitor = new MediaPlayerMonitor(self);
    mStillsMonitor = new StillsMonitor(self);
	
	[self switcherDisconnected];		// start with switcher disconnected
}

- (void)applicationWillTerminate:(NSNotification*)aNotification
{
	mSwitcherMonitor->Release();
	mSwitcherMonitor = NULL;
	
	mMixEffectBlockMonitor->Release();
	mMixEffectBlockMonitor = NULL;

	if (mSwitcherDiscovery)
	{
		mSwitcherDiscovery->Release();
		mSwitcherDiscovery = NULL;
	}
}

- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication*)sender
{
	return YES;
}

#pragma mark actions
//
// Actions
//
- (IBAction)connectButtonPressed:(id)sender
{
	NSString* address = [mAddressTextField stringValue];
	
	BMDSwitcherConnectToFailure			failReason;
	
	// Note that ConnectTo() can take several seconds to return, both for success or failure,
	// depending upon hostname resolution and network response times, so it may be best to
	// do this in a separate thread to prevent the main GUI thread blocking.
	HRESULT hr = mSwitcherDiscovery->ConnectTo((CFStringRef)address, &mSwitcher, &failReason);
	if (SUCCEEDED(hr))
	{
		[self switcherConnected];
	}
	else
	{
		NSString* reason;
		switch (failReason)
		{
			case bmdSwitcherConnectToFailureNoResponse:
				reason = NSLocalizedString(@"No response from Switcher", nil);
				break;
			case bmdSwitcherConnectToFailureIncompatibleFirmware:
				reason = NSLocalizedString(@"Switcher has incompatible firmware", nil);
				break;
			default:
				reason = NSLocalizedString(@"Connection failed for unknown reason", nil);
		}
		NSAlert* alert = [[[NSAlert alloc] init] autorelease];
		[alert setMessageText:reason];
		[alert addButtonWithTitle:NSLocalizedString(@"OK", nil)];
		[alert beginSheetModalForWindow:window completionHandler:nullptr];
	}
}

- (IBAction)cutButtonPressed:(id)sender
{
	mMixEffectBlock->PerformCut();
}

- (IBAction)autoButtonPressed:(id)sender
{
	mMixEffectBlock->PerformAutoTransition();
}

- (IBAction)FTBButtonPressed:(id)sender
{
	mMixEffectBlock->PerformFadeToBlack();
}

- (IBAction)programPopupChanged:(id)sender
{
	BMDSwitcherInputId selectedProgramInput = [[mProgramInputsPopup selectedItem] tag];
	mMixEffectBlock->SetProgramInput(selectedProgramInput);
}

- (IBAction)previewPopupChanged:(id)sender
{
	BMDSwitcherInputId selectedPreviewInput = [[mPreviewInputsPopup selectedItem] tag];
	mMixEffectBlock->SetPreviewInput(selectedPreviewInput);
}

- (IBAction)sliderChanged:(id)sender
{
	double position = [mSlider doubleValue] / 100.0;
	if (mMoveSliderDownwards)
		position = (100 - [mSlider doubleValue]) / 100.0;		// deal with flipped slider handle position

	mMixEffectBlock->SetTransitionPosition(position);
}

#pragma mark switcher connection change handling

- (void)switcherConnected
{
	HRESULT result;
	IBMDSwitcherMixEffectBlockIterator* iterator = NULL;
	IBMDSwitcherInputIterator* inputIterator = NULL;
	
	[mConnectButton setEnabled:NO];			// disable Connect button while connected
	
	NSString* productName;
	if (FAILED(mSwitcher->GetProductName((CFStringRef*)&productName)))
	{
		NSLog(@"Could not get switcher product name");
		return;
	}
	
	[mSwitcherNameLabel setStringValue:productName];
	[productName release];
	
	mSwitcher->AddCallback(mSwitcherMonitor);
	
	// Create an InputMonitor for each input so we can catch any changes to input names
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)&inputIterator);
	if (SUCCEEDED(result))
	{
		IBMDSwitcherInput* input = NULL;
		
		// For every input, install a callback to monitor property changes on the input
		while (S_OK == inputIterator->Next(&input))
		{
			InputMonitor* inputMonitor = new InputMonitor(input, self);
			input->Release();
			mInputMonitors.push_back(inputMonitor);
		}
		inputIterator->Release();
		inputIterator = NULL;
	}
		
	// Get the mix effect block iterator
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherMixEffectBlockIterator, (void**)&iterator);
	if (FAILED(result))
	{
		NSLog(@"Could not create IBMDSwitcherMixEffectBlockIterator iterator");
		goto finish;
	}
	
	// Use the first Mix Effect Block
	if (S_OK != iterator->Next(&mMixEffectBlock))
	{
		NSLog(@"Could not get the first IBMDSwitcherMixEffectBlock");
		goto finish;
	}
	
	mMixEffectBlock->AddCallback(mMixEffectBlockMonitor);
	
	[self mixEffectBlockBoxSetEnabled:YES];
	[self updatePopupButtonItems];
	[self updateSliderPosition];
	[self updateTransitionFramesTextField];
	[self updateFTBFramesTextField];
    
    [self switcherConnected_SwitcherMediaPool];
	
finish:
	if (iterator)
		iterator->Release();
}

- (void)switcherDisconnected
{
	[mConnectButton setEnabled:YES];			// enable connect button so user can re-connect
	[mSwitcherNameLabel setStringValue:@""];
	
	[self mixEffectBlockBoxSetEnabled:NO];
	
	// cleanup resources created when switcher was connected
	for (std::list<InputMonitor*>::iterator it = mInputMonitors.begin(); it != mInputMonitors.end(); ++it)
	{
		(*it)->Release();
	}
	mInputMonitors.clear();
	
	if (mMixEffectBlock)
	{
		mMixEffectBlock->RemoveCallback(mMixEffectBlockMonitor);
		mMixEffectBlock->Release();
		mMixEffectBlock = NULL;
	}
	
	if (mSwitcher)
	{
		mSwitcher->RemoveCallback(mSwitcherMonitor);
		mSwitcher->Release();
		mSwitcher = NULL;
	}
}

#pragma mark GUI updates
//
// GUI updates
//
- (void)updatePopupButtonItems
{
	HRESULT result;
	IBMDSwitcherInputIterator* inputIterator = NULL;
	IBMDSwitcherInput* input = NULL;
	
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)&inputIterator);
	if (FAILED(result))
	{
		NSLog(@"Could not create IBMDSwitcherInputIterator iterator");
		return;
	}
	
	[mProgramInputsPopup removeAllItems];
	[mPreviewInputsPopup removeAllItems];
    mNumberOfInputs = 0;

	while (S_OK == inputIterator->Next(&input))
	{
		NSString* name;
		BMDSwitcherInputId id;

		input->GetInputId(&id);
		input->GetLongName((CFStringRef*)&name);
		
		[mProgramInputsPopup addItemWithTitle:name];
		[[mProgramInputsPopup lastItem] setTag:id];
		
		[mPreviewInputsPopup addItemWithTitle:name];
		[[mPreviewInputsPopup lastItem] setTag:id];
        
        mNumberOfInputs++;
		
		input->Release();
		[name release];
	}
	inputIterator->Release();
	
	[self updateProgramButtonSelection];
	[self updatePreviewButtonSelection];
}

- (void)updateProgramButtonSelection
{
	BMDSwitcherInputId	programId;
	mMixEffectBlock->GetProgramInput(&programId);
	[mProgramInputsPopup selectItemWithTag:programId];
}

- (void)updatePreviewButtonSelection
{
	BMDSwitcherInputId	previewId;
	mMixEffectBlock->GetPreviewInput(&previewId);
	[mPreviewInputsPopup selectItemWithTag:previewId];
}

- (void)updateInTransitionState
{
	bool inTransition;
	mMixEffectBlock->GetInTransition(&inTransition);
	
	if (inTransition == false)
	{
		// Toggle the starting orientation of slider handle if a transition has passed through halfway
		if (mCurrentTransitionReachedHalfway)
		{
			mMoveSliderDownwards = ! mMoveSliderDownwards;
			[self updateSliderPosition];
		}
		
		mCurrentTransitionReachedHalfway = false;
	}
}

- (void)updateSliderPosition
{
	double position;
	mMixEffectBlock->GetTransitionPosition(&position);
	
	// Record when transition passes halfway so we can flip orientation of slider handle at the end of transition
	mCurrentTransitionReachedHalfway = (position >= 0.50);

	double sliderPosition = position * 100;
	if (mMoveSliderDownwards)
		sliderPosition = 100 - position * 100;		// slider handle moving in opposite direction
	
	[mSlider setDoubleValue:sliderPosition];
	[mLevelIndicator setDoubleValue:position * 20];
}

- (void)updateTransitionFramesTextField
{
	uint32_t framesRemaining;
	mMixEffectBlock->GetTransitionFramesRemaining(&framesRemaining);
	[mTransitionFramesTextField setIntegerValue:framesRemaining];
}

- (void)updateFTBFramesTextField
{
	uint32_t framesRemaining;
	mMixEffectBlock->GetFadeToBlackFramesRemaining(&framesRemaining);
	[mFTBFramesTextField setIntegerValue:framesRemaining];
}

- (void)mixEffectBlockBoxSetEnabled:(bool)enabled
{
	[mProgramInputsPopup setEnabled:enabled];
	[mPreviewInputsPopup setEnabled:enabled];
	[mCutButton setEnabled:enabled];
	[mAutoButton setEnabled:enabled];
	[mFTBButton setEnabled:enabled];
	[mSlider setEnabled:enabled];
	[mTransitionFramesTextField setEnabled:enabled];
	[mFTBFramesTextField setEnabled:enabled];
}


#pragma mark SwitcherMediaPool example code


// switcherConnected from SwitcherMediaPool example
- (void)switcherConnected_SwitcherMediaPool
{
    HRESULT result;
    REFIID mediaPoolIID = IID_IBMDSwitcherMediaPool;
    IBMDSwitcherMediaPlayerIterator* mediaPlayerIterator = NULL;
    uint32_t clipCount;
    
    // update UI enabled states
    [mMediaPlayerSourcePopup setEnabled:YES];
    [self enableMediaPlayerButtons:true];
    
    // get the media player iterator
    result = mSwitcher->CreateIterator(IID_IBMDSwitcherMediaPlayerIterator, (void**)&mediaPlayerIterator);
    if (FAILED(result))
    {
        NSLog(@"Could not create IBMDSwitcherMediaPlayerIterator iterator\n");
        goto finish;
    }
    
    // get all media players
    while (true)
    {
        IBMDSwitcherMediaPlayer* mediaPlayer = NULL;
        result = mediaPlayerIterator->Next(&mediaPlayer);
        if (result != S_OK)
            break;
        
        mMediaPlayers.push_back(mediaPlayer);
    }
    
    if (FAILED(result))
    {
        NSLog(@"Could not iterate media players\n");
        goto finish;
    }
    
    // get media pool
    result = mSwitcher->QueryInterface(mediaPoolIID, (void**)&mMediaPool);
    if (FAILED(result))
    {
        NSLog(@"Could not get IBMDSwitcherMediaPool interface\n");
        goto finish;
    }
    
    // get stills interface
    result = mMediaPool->GetStills(&mStills);
    if (FAILED(result))
    {
        NSLog(@"Could not get IBMDSwitcherStills interface\n");
        goto finish;
    }
    
    // get number of clips
    result = mMediaPool->GetClipCount(&clipCount);
    if (FAILED(result))
    {
        NSLog(@"Could not get clip count\n");
        goto finish;
    }
    
    // get all clip interfaces
    for (uint32_t clipIndex = 0; clipIndex < clipCount; ++clipIndex)
    {
        IBMDSwitcherClip* clip = NULL;
        
        result = mMediaPool->GetClip(clipIndex, &clip);
        if (FAILED(result))
        {
            NSLog(@"Could not get clip interface\n");
            goto finish;
        }
        
        mClips.push_back(clip);
    }
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        goto finish;
    }
    
    // set monitors, which will flush the callbacks and update the GUI
    
    mMediaPlayer1Monitor->setMediaPlayer(mMediaPlayers[0]);
    mStillsMonitor->setStills(mStills);
    
    if (mClipMonitors.size() > 0)
        NSLog(@"Clip monitors have not been deleted\n");
    
    // create clip monitors here because we don't know clip count on initialization
    for (unsigned long clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
    {
        ClipMonitor* clipMonitor = new ClipMonitor(self);
        clipMonitor->setClip(mClips[clipIndex]);
        mClipMonitors.push_back(clipMonitor);
    }
    /*
    // create still transfer
    mStillTransfer = new StillTransfer(self, window, mSwitcher, mMediaPool, mStills);
    
    // create clip transfers
    for (unsigned long clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
    {
        ClipTransfer* clipTransfer = new ClipTransfer(self, window, mSwitcher, mMediaPool, mClips[clipIndex]);
        mClipTransfers.push_back(clipTransfer);
    }
    */
finish:
    if (mediaPlayerIterator)
        mediaPlayerIterator->Release();
}

- (void)enableMediaPlayerButtons:(bool)enabled
{
    // sets the media player button widgets enabled state
    
    [mMediaPlayerBeginButton setEnabled:enabled];
    [mMediaPlayerPreviousButton setEnabled:enabled];
    [mMediaPlayerPlayButton setEnabled:enabled];
    [mMediaPlayerNextButton setEnabled:enabled];
    [mMediaPlayerLoopButton setEnabled:enabled];
    
}

- (void)onMediaPlayerSourceChanged
{
    // the source has changed
    
    // update the selected source
    [self updateMediaPlayerPopupSelection];
}

- (void)onMediaPlayerPlayingChanged
{
    // the switcher has notified us that the playing property has changed
    
    bool playing;
    HRESULT result;
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // get the playing property
    result = mMediaPlayers[0]->GetPlaying(&playing);
    if (FAILED(result))
    {
        NSLog(@"Could not get playing\n");
        return;
    }
    
    // update the state of the button
    [mMediaPlayerPlayButton setState:playing];
}

- (void)onMediaPlayerBeginChanged
{
    // the switcher has notified us that the 'at beginning' property has changed
    
    bool atBegining;
    HRESULT result;
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // get the 'at beginning' property
    result = mMediaPlayers[0]->GetAtBeginning(&atBegining);
    if (FAILED(result))
    {
        NSLog(@"Could not get 'at beginning'\n");
        return;
    }
    
    // update the state of the button
    [mMediaPlayerBeginButton setState:atBegining];
}

- (void)onMediaPlayerLoopChanged
{
    // the switcher has notified us that the loop property has changed
    
    bool loop;
    HRESULT result;
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // get the loop property
    result = mMediaPlayers[0]->GetLoop(&loop);
    if (FAILED(result))
    {
        NSLog(@"Could not get loop\n");
        return;
    }
    
    // update the state of the button
    [mMediaPlayerLoopButton setState:loop];
}

- (void)onStillClipNameValidChanged
{
    // We could update only the item that has changed, but this is simpler
    [self updateMediaPopupItems:mMediaPlayerSourcePopup];
}

- (void)updateMediaPopupItems:(NSPopUpButton*)comboBox;
{
    HRESULT result;
    uint32_t stillCount;
    int comboIndex = (int)[comboBox indexOfSelectedItem]; // save current index
    
    // check we have the media pool
    if (! mMediaPool)
    {
        NSLog(@"No media pool\n");
        return;
    }
    
    // clear existing combo box items
    [comboBox removeAllItems];
    
    // append a combox box item for each clip
    for (unsigned long clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
    {
        NSString* clipName = NULL;
        IBMDSwitcherClip* clip = mClips[clipIndex];
        
        // if the clip is invalid, the clip name will be blank
        result = clip->GetName((CFStringRef*)&clipName);
        if (FAILED(result))
        {
            NSLog(@"Could not get clip name\n");
            return;
        }
        
        // add the clip item
        NSString* itemText = [NSString stringWithFormat:@"Clip %lu: %@", clipIndex + 1, clipName];
        [comboBox addItemWithTitle:itemText];
        
        [clipName release];
    }
    
    // check we have stills
    if (! mStills)
    {
        NSLog(@"No stills\n");
        return;
    }
    
    // get the number of stills
    result = mStills->GetCount(&stillCount);
    if (FAILED(result))
    {
        NSLog(@"Could not get still count\n");
        return;
    }
    
    // append a combo box item for each still
    for (uint32_t stillIndex = 0; stillIndex < stillCount; ++stillIndex)
    {
        NSString* stillName = NULL;
        
        // if the still is invalid, the still name will be blank
        result = mStills->GetName(stillIndex, (CFStringRef*)&stillName);
        if (FAILED(result))
        {
            NSLog(@"Could not get still name\n");
            return;
        }
        
        // add the still item
        NSString* itemText = [NSString stringWithFormat:@"Still %i: %@", stillIndex + 1, stillName];
        [comboBox addItemWithTitle:itemText];
        
        [stillName release];
    }
    
    // restore previously selected index
    [comboBox selectItemAtIndex:comboIndex];
}

- (void)updateMediaPlayerPopupSelection;
{
    // This method sets the media player combo box selected
    // item to the source of the media player and sets the
    // media player buttons enabled if the selected item is a clip.
    
    HRESULT result;
    BMDSwitcherMediaPlayerSourceType sourceType;
    uint32_t sourceIndex;
    bool valid = false;
    
    // check we have the media pool
    if (! mMediaPool)
    {
        NSLog(@"No media pool\n");
        return;
    }
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // get the source
    result = mMediaPlayers[0]->GetSource(&sourceType, &sourceIndex);
    if (FAILED(result))
    {
        NSLog(@"Could not get media player source\n");
        return;
    }
    
    // set the combo to the media player source
    if (sourceType == bmdSwitcherMediaPlayerSourceTypeClip)
    {
        int popupIndex = sourceIndex; // clip items are listed first in the combo box
        
        // check the clip index is valid
        if (sourceIndex >= (int)mClips.size())
        {
            NSLog(@"Invalid clip selection\n");
            return;
        }
        
        // only enable media player buttons if the clip is valid
        result = mClips[sourceIndex]->IsValid(&valid);
        if (FAILED(result))
        {
            NSLog(@"Could not get clip validity\n");
            return;
        }
        
        [mMediaPlayerSourcePopup selectItemAtIndex:popupIndex];
    }
    else if (sourceType == bmdSwitcherMediaPlayerSourceTypeStill)
    {
        uint32_t popupIndex = (uint32_t)mClips.size() + sourceIndex; // still items are listed second in the combo box
        uint32_t stillCount;
        
        // get the number of stills
        result = mStills->GetCount(&stillCount);
        if (FAILED(result))
        {
            NSLog(@"Could not get still count\n");
            return;
        }
        
        // check the still index is valid
        if (sourceIndex >= stillCount)
        {
            NSLog(@"Invalid still selection\n");
            return;
        }
        
        [mMediaPlayerSourcePopup selectItemAtIndex: popupIndex];
    }
    else
    {
        NSLog(@"Unknown media player source type\n");
        return;
    }
    
    [self enableMediaPlayerButtons:valid];
}

- (IBAction)mediaPlayerSourcePopupChanged:(id)sender
{
    uint32_t comboIndex = (uint32_t)[mMediaPlayerSourcePopup indexOfSelectedItem];
    [self selectMediaPlayerSource:comboIndex];
}

- (void) selectMediaPlayerSource:(uint32_t) mpIndex
{
    HRESULT result;
    uint32_t clipCount;
    BMDSwitcherMediaPlayerSourceType sourceType;
    int sourceIndex;
    
    // check we have the media pool
    if (! mMediaPool)
    {
        NSLog(@"No media pool\n");
        return;
    }
    
    // get the clip count
    result = mMediaPool->GetClipCount(&clipCount);
    if (FAILED(result))
    {
        NSLog(@"Could not get clip count\n");
        return;
    }
    
    // determine if source is clip or still
    if (mpIndex < clipCount)
    {
        // source is a clip
        sourceType = bmdSwitcherMediaPlayerSourceTypeClip;
        sourceIndex = mpIndex;
    }
    else
    {
        // source is a still
        sourceType = bmdSwitcherMediaPlayerSourceTypeStill;
        sourceIndex = mpIndex - clipCount;
    }
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // set media player 1 source
    result = mMediaPlayers[0]->SetSource(sourceType, sourceIndex);
    if (FAILED(result))
    {
        NSLog(@"Could not set media player 1 source\n");
        return;
    }
}


- (IBAction)beginButtonClicked:(id)sender
{
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // toggle the 'at beginning' property, the button state will change upon notification from the switcher
    HRESULT result = mMediaPlayers[0]->SetAtBeginning();
    if (FAILED(result))
    {
        NSLog(@"Could not set 'at beginning'\n");
        return;
    }
}

- (IBAction)previousButtonClicked:(id)sender
{
    HRESULT result;
    uint32_t clipFrameIndex;
    uint32_t clipIndex = (uint32_t)[mMediaPlayerSourcePopup indexOfSelectedItem];
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // check we have the clip
    if (clipIndex > mClips.size())
    {
        NSLog(@"No valid clip selected\n");
        return;
    }
    
    // get the clip frame index
    result = mMediaPlayers[0]->GetClipFrame(&clipFrameIndex);
    if (FAILED(result))
    {
        NSLog(@"Could not get clip frame index\n");
        return;
    }
    
    // we can't goto the previous frame if we are on the first frame
    if (clipFrameIndex > 0)
    {
        // set clip frame index to previous frame
        result = mMediaPlayers[0]->SetClipFrame(clipFrameIndex - 1);
        if (FAILED(result))
        {
            NSLog(@"Could not set clip frame index\n");
            return;
        }
    }
}

- (IBAction)playButtonClicked:(id)sender
{
    HRESULT result;
    bool playing;
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // get the playing property
    result = mMediaPlayers[0]->GetPlaying(&playing);
    if (FAILED(result))
    {
        NSLog(@"Could not get playing\n");
        return;
    }
    
    // toggle the playing property, the button state will change upon notification from the switcher
    result = mMediaPlayers[0]->SetPlaying(! playing);
    if (FAILED(result))
    {
        NSLog(@"Could not set playing\n");
        return;
    }
}

- (IBAction)nextButtonClicked:(id)sender
{
    HRESULT result;
    uint32_t clipFrameCount;
    uint32_t clipFrameIndex;
    uint32_t clipIndex = (uint32_t)[mMediaPlayerSourcePopup indexOfSelectedItem];
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // check we have the clip
    if (clipIndex > mClips.size())
    {
        NSLog(@"No valid clip selected\n");
        return;
    }
    
    // check we have the clip
    result = mClips[clipIndex]->GetFrameCount(&clipFrameCount);
    if (FAILED(result))
    {
        NSLog(@"Could not get clip frame count\n");
        return;
    }
    
    // get the clip frame index
    result = mMediaPlayers[0]->GetClipFrame(&clipFrameIndex);
    if (FAILED(result))
    {
        NSLog(@"Could not get clip frame index\n");
        return;
    }
    
    // we can't goto the next frame if we are on the last frame
    if (++clipFrameIndex < clipFrameCount)
    {
        // set clip frame index to previous frame
        result = mMediaPlayers[0]->SetClipFrame(clipFrameIndex);
        if (FAILED(result))
        {
            NSLog(@"Could not set clip frame index\n");
            return;
        }
    }
}

- (IBAction)loopButtonClicked:(id)sender
{
    HRESULT result;
    bool loop;
    
    // check we have media player 1
    if (mMediaPlayers.size() < 1)
    {
        NSLog(@"No media player 1\n");
        return;
    }
    
    // get the loop property
    result = mMediaPlayers[0]->GetLoop(&loop);
    if (FAILED(result))
    {
        NSLog(@"Could not get loop\n");
        return;
    }
    
    // toggle the loop property, the button state will change upon notification from the switcher
    result = mMediaPlayers[0]->SetLoop(! loop);
    if (FAILED(result))
    {
        NSLog(@"Could not set loop\n");
        return;
    }
}


@end
